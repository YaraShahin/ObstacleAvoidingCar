# Obstacle Avoiding Car-like Robot
## Introduction
`ObstacleAvoidingCar.py` is a robotics project made by level 4 electrical and electronics engineering students, Yara Shahin and Mohamed Abbas, as part of our computer engineering module. In this project, we attempt to use the python version of the robotics toolbox, developed by Peter Corke, to program a car-like robot to autonomously navigate to a user-input target while avoiding a number of obstacles placed randomly throughout the 20x20 map. The work on this project consisted of three main milestones: Algorithm planning, implementation, and evaluation. 
## Algorithm Planning
In this stage, both students brainstormed an algorithm on developing a theoretical approach to the obstacle avoidance task. We came up with our new algorithm after being inspired by the previous approaches to this task.
### Literature Review: Existing Obstacle Avoidance Algorithms
#### Fuzzy Logic Controller Technique
Technique used to divide a large problem into a set of sub-problems that are less complex. In the obstacle avoidance context, it works by dividing the surrounding area into ranges by angle and using “If-then” statements to determine which range would be best to move the robot into [1]. <img align="right" width="150" height="100" src="/images/figure1.png">
#### Bug 1 Algorithm
The robot moves towards the goal until it encounters an obstacle. The robot then takes a full revolution around the robot and determines the take-off point of the shortest path [2]. Beside this technique’s lack of effeciency, it would render ineffective in an environment of high obstacle density. 
#### Bug 2 Algorithm
The robot moves towards the goal through the calculated angle from the initial point until it encounters an obstacle. The robot moves along the sides of the obstacle until it finds a point with the same angle [3]. This algorithm is easier to implement and more efficient than bug 1 algorithm. Our algorithm is partially inspired by this algorithm as we will see in the later section.
#### Tangent Bug Algorithm
The robot finds tangents to the obstacle and calculates distances of robot from points where they touch the obstacle. The robot then takes path of the tangent which maximally decreases the distance which has to be crossed from the current position to the obstacle’s tangent and then to the goal [4]. This algorithm is very similar to the one we use in this project. The main difference is in the decision making as the robot chooses not the least distance path, rather the path of the least angle diversion from the goal’s. 
### Our Proposed Algorithm
- The robot calculates the angle to the goal and keeps moving in that direction with a fixed speed until it faces an obstacle. An obstacle is detected if it is within 5 units of the robot within the minimum range of angle the robot needs to move ahead in the goal’s direction. This range of angles is calculated based on the arc sin of the angle formed by the triangle in which the distance to the obstacle is the hypotenous and half the size of the robot’s front is a side, as shown in figure 2. <img align="right" width="250" height="250" src="/images/figure2.jpg">
- Once the robot faces an obstacle, it loops over all the obstacles within 10 units. Assuming the obstacles are of points with negligable size, the robot calculates the angle on their lefts and rights that would fit the robot, as illustrated in figure 3. If an angle fits the robot according to the calculation illustrated above, the angle is appended in a list. <img align="right" width="200" height="200" src="/images/figure3.jpg">
- The robot moves in the angle which would result in minimal diversion from the reference angle to goal. In extreme cases where the robot can’t find any fitting paths, the robot stops. 
